#![warn(rust_2018_idioms)]
#![deny(unsafe_op_in_unsafe_fn)]

use std::mem::size_of;

pub const MSG_DATA_MAX: usize = 4096;

#[repr(u32)]
pub enum MessageType {
    ExternExecve = 1,
}

pub type MessageData = [u8; MSG_DATA_MAX];

// TODO: Optimize layout if possible
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct Message {
    pub length: u32,
    pub mtype: u32,
    pub data: MessageData,
}
impl Message {
    pub fn new(mtype: MessageType, msg_data: &[u8]) -> Self {
        let mut data = [0; MSG_DATA_MAX];
        data[..msg_data.len()].copy_from_slice(msg_data);

        Self {
            length: msg_data.len() as u32,
            mtype: mtype as u32,
            data,
        }
    }

    pub fn data(&self) -> &[u8] {
        &self.data[..self.length as usize]
    }

    pub fn as_bytes(&self) -> &[u8] {
        // SAFETY: TODO, REVIEW!
        unsafe { &*(self as *const Message as *const [u8; size_of::<Message>()]) }
    }

    /// Creates a `Message` from bytes
    ///
    /// # Safety
    ///
    /// `bytes` must be a valid `Message` as created by [`as_bytes`](Message::as_bytes).
    /// Any other bytes are UB.
    pub unsafe fn from_bytes(bytes: &[u8]) -> Self {
        assert!(bytes.len() == SIZE_OF_MESSAGE);
        let bytes = bytes.try_into().unwrap();
        unsafe { MessageOrBytes { bytes }.message }
    }
}

pub const SIZE_OF_MESSAGE: usize = size_of::<Message>();

union MessageOrBytes {
    message: Message,
    bytes: [u8; SIZE_OF_MESSAGE],
}
